### Speaking a Protocol
------
在第二个例子中，我们创建了一个URL并且取出了和这个URL相关联的文档。这样的操作似乎十分简单，而从单纯地浏览器的行为来看，这个操作却不那么简单。URL之所以能够用来提取对应的文件是因为：URL本身描述了，对于网页上一个特定的文档，用户应该上哪里找到他以及怎样提取它。URL包含了协议的名称，紧接着的是文件所在主机的名字，最后以该文件在主机上的路径结尾。search2.py程序能够解析URL并提取与之关联的文件正是因为URL为相对底层的协议提供了找到这个文件的方法。

实际上，URL使用的底层协议就是著名的HTTP。HTTP是当今几乎所有网络交互的基础。在本书的Section2，我们将有更多的机会学习这一协议。同时，也正是HTTP使得诸如urllib这样的Python内建库能够做到获取Google Maps的返回结果这一功能。那么，我们是否能够使用更加底层的方法，直接使用HTTP协议来获取Google Maps的结果呢？请看search3.py

##### Listing 1–3. Making a Raw HTTP Connection to Google Maps

```python
#!/usr/bin/env python
# Foundations of Python Network Programming - Chapter 1 - search3.py

import httplib
try:
	import json
except ImportError: # for Python 2.5
	import simplejson as json

path = ('/maps/geo?q=207+N.+Defiance+St%2C+Archbold%2C+OH&output=json&oe=utf8')
connection = httplib.HTTPConnection('maps.google.com')
connection.request('GET', path)

rawreply = connection.getresponse().read()
reply = json.loads(rawreply)

print reply['Placemark'][0]['Point']['coordinates'][:-1]
```

在以上的代码中，任何和URL有关的概念全都被去掉了，实际上我们根本没有import任何和URL相关的库。我们在这里直接操作HTTP协议：利用HTTP协议同一个特定一个机器建立连接，对一个特定的路径发送GET请求，最后直接从HTTP链接中读取我们所要的结果。这里不像之前那样允许我们将我们想要的参数传入一个字典，我们只能通过在path中手动设置来获取我们需要的参数：path中有一个?后面接着的是我们想要获取的参数名称（name=value的形式）。



### A Raw Network Conversation
------
HTTP协议不能凭空地在两台机器之间收发数据，必须利用一些简单的抽象组件来操作HTTP协议。**实际上，它只是运用了现代操作系统的能力来支持两个不同程序跨越IP网络之间的纯文本对话**。换句话说，HTTP协议**通过指定往返于两台主机之间的文本信息的具体格式来实现自身**。

当我们穿过HTTP观察它下面的机制的时候，我们就触及了Python所能够让我们比较容易操作的网络的最低层次。仔细观察下面的search4.py。该程序的效果和之前的三个一样，**只不过在这里我们只是通过Internet发送纯文本信息，并接受文本信息。**

```python
#!/usr/bin/env python
# Foundations of Python Network Programming - Chapter 1 - search4.py

import socket
sock = socket.socket()
sock.connect(('maps.google.com', 80))
sock.sendall(
	'GET /maps/geo?q=207+N.+Defiance+St%2C+Archbold%2C+OH'
	'&output=json&oe=utf8&sensor=false HTTP/1.1\r\n' #注意第一行到这里结束
	'Host: maps.google.com:80\r\n'
	'User-Agent: search4.py\r\n'
	'Connection: close\r\n'
	'\r\n')
rawreply = sock.recv(4096)
print rawreply
```

从search3到search4，我们跨出了重要的一步。在先前的程序中我们都使用了Python库，来帮助我们处理复杂的协议。这些库都是用Python语言完成的。但是在search4中，我们接触到了比较底层的元素：我们直接调用`socket()`函数，该函数**由我们主机的操作系统提供**(Python进行封装)，用来**支持IP网络之间的基本网络通信**。换句话说，我们在这里使用的方法的**机理和底层系统程序员使用C语言**来完成网络操作的方法是**相同**的。

可以看到，在上述的程序中，`sendall()`方法里传入的字符串(注意是一个字符串)包含了GET方法名称、我们想要提取的文件所在路径以及我们所支持的HTTP的版本。之后，是一系列由各种冒号、变量名、变量值组成的头(header)，最后开始了新的一行，表示请求信息结束。

运行search4，通过将返回结果打印在屏幕上，我们可以得到以下反馈信息：

```
HTTP/1.1 200 OK
Content-Type: text/javascript; charset=UTF-8
Vary: Accept-Language
Date: Wed, 21 Jul 2010 16:10:38 GMT
Server: mafe
Cache-Control: private, x-gzip-ok=""
X-XSS-Protection: 1; mode=block
Connection: close

{
  "name": "207 N. Defiance St, Archbold, OH",
  "Status": {
    "code": 200,
    "request": "geocode"
  },
  "Placemark": [ {
    ...
    "Point": {
      "coordinates": [ -84.3063479, 41.5228242, 0 ]
    }
  } ]
}
```

我们可以看到，HTTP回复和HTTP请求的结构比较类似：第一行是状态行，紧接着一系列行都描述了韩惠内容的格式。之后是一个空行。空行之后才是Response的真正内容——一个JSON格式的文本。该文本恢复了我们想要查询的变量（Google Maps中的位置信息）。所有前面的状态行和头都是`Python.httplib`所要进行处理的底层细节

### Turtles all the way down
------
希望你通过以上的几个例子已经对Python网络编程有了初步的了解。我们接下来想要就上述的几个例子来对Python网络编程简单地谈几点。

首先，你可能对什么是协议栈（protocol stack）有了更深入地了解：**协议栈建立了一个高层次的、语义上十分复杂的会话，这个高层次的会话建立在更简单的、更加基础的会话上。**这些会话，究其根本，**不过是两台计算机通过网络硬件互相发送字符串信息。**我们在以上的四个例子中所涉及到的协议栈一共有四层：

- 谷歌地图URL返回JSON格式的地理坐标数据
- URL定义了可从此URL中提取的文件
- HTTP使用socket支持GET这样的文档指令
- Socket只知道如何发送和接受信息

可以看到，以上协议栈中的每一层协议都使用了更加底层的（位于这一层下面）工具。同时，每层协议都提供了访问更高层协议（位于这一层上面）的方法。

此外，我们可以看到，Python能够支持我们操作上述四层协议中的每一层网络。只有当我们使用特定厂商和公司的协议（search1.py 操作最高层次网络）时，例如发出Google能接受的requests时，我们才需要使用相关的第三方库。**对于下面三层协议中的操作，我们用标准库就可以实现。**无论是从特定的URL提取文件还是利用最原始的socket收发字符串，Python均能提供对应的函数和类供我们使用。

还有，注意到以上四个例子，每当笔者使用更加低层次的协议时，程序的质量就会下降：例如在search2.py和search3.py中，笔者就开始使用类似于“form structure”和“hostnames”这种不慎灵活的东西了；search4.py中更甚，甚至包含了完全手写的、参数化了的HTTP request，这种request的结构对于Python来说十分不清楚。自然，这些对象也不会直接提供解析HTTP response和处理网络连接错误的方法。

对于接下来的每一章节，我们都应该注意这一点：正确实现网络协议很困难。**在任何情况下，都要尽可能地使用标准库和第三方库。**比如在写客户端的时候，很多人都会过分简化自己的代码：忽略可能出现的异常、只考虑最可能收到的response。这样写出来的代码都是十分脆弱的：因为这类开发者对于正在开发的客户端可能连接的服务器的情况知之甚少。相反，直接使用已经搭建好的第三方库，开发者就能更加得心应手——为了满足各色的Python开发者的需求，第三方库的开发人员早就考虑到了各种各样的复杂情况。

 最后，像谷歌地图这样能够提取地理位置信息的高层网络协议一般会隐藏掉用来实现它自身的底层网络——如果你只是使用googlemaps库，你也许根本不会意识到URLs和HTTP这些底层机制的存在。

**下面提一个值得深思的问题：发生在底层的错误能不能被高层协议正确地封装？**如果发生了无法连接到Google的错误，Python能不能抛出一个底层网络异常？对于这个问题，我们将在本书关于网络异常的章节深入讨论。

最后一点。也是会在本书的学习中一直伴随读者的一个事实：search4.py中向Google发送request时，socket不是最底层的协议！**在socket下面，仍然有更加底层的网络协议——只不过Python已经无法操作这些协议了，只能通过操作系统进行操作。**

位于socket API 之下的协议栈是：

- TCP：socket在这个协议中用来维持两个程序之间的网络通信。
- IP：定义如何在两个计算机之间发送数据包
- 连接层：由以太网接口和无线网卡这样的硬件组成，可以在直接相连的硬件计算机之间发送信息 

在本章接下来的内容和后面的两章中，我们将会深入探索最底层协议，从IP层开始，之后学习来年各种基本的协议——UDP和TCP——是如何分别支持两种基本通讯类型的。

### The Internet Protocol
------
网络是一种**资源共享手段**：无论是把几台计算机相连的**局域网**还是连接一个区域内全部计算机的**互联网**。

电脑上各种各样需要被（不同程序）共享的资源——光驱、内存、CPU，都被操作系统管理着。只有这样，程序们才能在计算机上安全地运行，获取计算机上的资源，而不互相干扰。网络也是这样一种**需要操作系统管理的资源**，这样才能保证程序们**可以互相通信**但**不会干扰**到发生在一个网络上的**另一组通信**。

像网卡、无线发射器以及USB端口这些计算机赖以通信的**网络硬件，都具有**同其他业想要进行通信设备**共享同一套物理媒介（而不发生冲突）的能力**：比如，很多网卡会被插在同一个槽上；30个无线网卡可能会共享同一个频道；一个调制解调器（这里是用电话线上网的梗）会利用EE中常见的频域多路技术来避免他自己的数字信号和同一个线路上其他的数字信号，比如你打电话时发出的电话信号，发生冲突。

<u>以上网络设备共享同一种**基本通信单元——电流，或者叫“包”。**一个“包”其实是一串二进制数字（0-1序列）。它的长度从几个比特到几千个比特不等。**包，作为通信的基本单元，在不同网络设备之间传输。**目前确实有一些特殊网络（尤其在电信行业中），这些网络中同一条数据线上的每个比特都可能分别路由到不同的设备（以比特作为传输的基本单元）。但是在现代计算机上简历数据网络更为普遍的技术是以来更大的单元——数据包——去建立的。</u>

<u>在物理层中，包一般有两个性质： 其一包能代表二进制字符串自身所承载的数据；此外包还代表它将被发送到的地址。地址一般是另一块网卡上特有的标识符，因此也就代表了和这块网卡相连的电脑（当然此时此刻目标计算机也必须和网络相连）。**网卡的作用就是收发这些包**，同时**避免让操作系统去接触线路和电压这样的底层细节**。</u>

那什么是****网络协议****呢？

<u>网络协议是**将全世界所有连接到"Internet（互联网）"的计算机的地址编成一个系统的一套方案**，同时协议要能**满足包在这些计算机之间相互传输**。理想状态下。浏览器这样的应用应该能在任何地方连接到任何一个主机，而不需要考虑使用多么复杂的方式或路径和这个主机进行连接。</u>

**在Python编程中，鲜有机会从上述这么底层的角度来看待网络协议。**不过有些时候，知道网络如何运作总是有帮助的。

### IP Address
------
前面所述的网络协议会给每个连接到网络的计算机指派一个4比特地址（一个32位的二进制数， 常常被分割成4个八位二进制数字）。这种地址一般表示为几组被句号分开的四个数。**每一个四位数代表4比特地址中的一个比特**。所以，被逗号分隔开的每个数字都可以从0-255的范围内取值。所以IP地址是这个样子的：130.207.67.103。 因为纯粹的数字地址不便记忆，所以**真实的互联网会显示主机名称而不显示IP地址。**比如，用户可以输入google.com访问谷歌而根本不用理会这个地址背后的IP，虽然计算机其实是利用IP来传输包的，而不用google.com。

在下面getname.py这个程序中，可以十分容易地实现令**任意一个操作系统（Windows, Linux, Mac OS或者其他的操作系统）去解析google.com这个主机名**。“域名服务（DNS）”，这种能够实现主机名称查询的特殊网络服务是相当复杂的，我们会在后面的章节深入探讨。


#####Listing 1–6. Turning a Hostname into an IP Address
```python
#!/usr/bin/env python
# Foundations of Python Network Programming - Chapter 1 - getname.py

import socket
hostname = 'maps.google.com'
addr = socket.gethostbyname(hostname)
print 'The address of', hostname, 'is', addr
```

目前，只需要记住以下两点：
- 第一，无论什么样的网络应用，**都会使用4比特IP向目的地传输数据包**。

- 第二，**将主机名映射成IP地址的复杂工作，一般是操作系统完成的**。

  ​

  就如同操作网络协议的其他细节那样，**操作系统对用户（你）和Python代码都不公开这些底层细节，而去自己处理它们。**

  然而实地操作要比单纯描述难得多，地球已经逐渐面临4比特IP地址枯竭的困境。所以，人们采用一种被称作IPv6的长达16比特的地址来满足人类的需求。它们写起来不像4比特地址那样，它们是这个样子的——fe80::fcfd:4aff:fecf:ea4e 。

  但只要你的代码能接收IP地址或者主机名，并能直接把它们交给某一个网络库进行处理，那么你**基本上不需要关心IPv4和IPv6的差别**。运行你的Python代码的操作系统能自动识别你的程序使用的IP地址的版本，并能对应地进行翻译。一般来说，IP地址要从左往右读，前一个或者两个比特代表一个organization，紧接着的一个比特代表目标机器所在的那个子网。最后几个比特把地址限定到了某个特定的机器或者服务器。有一些范围的IP地址是由特殊含义的，比如：

- 127.*.*. * : **以127开头的 IP地址代表：他们就在应用所运行的机器上**，比如，当你的浏览器或者FTP客户端或者某个Python程序想要连接到一个以127开头的IP的时候，它实际上**在和运行于同一台电脑上**的其他程序或者服务器应用进行通信。大多数机器都会用到这个IP范围内的一个IP地址 127.0.0.1。这个地址代表：**程序所运行的那个机器本身**，也可以用主机名称localhost进行访问。

- 10.*.*. * , 172.16–31.*.*, 192.168.*.*: **这三个IP范围被保留做为私有子网**。运行Internet的机构曾做出郑重承诺：**绝不会把这三个范围内的IP分配给任何公司来运营网络服务 。**这些IP被保证没有任何实际含义，**这些范围内没有主机名供你连接。**因此，这些IP对你是**免费的**，你可以在这些IP内自由设置IP地址，同时又能确保从互联网的其他地方无法访问这些IP地址。

  ​

  你在家就能看到这些私有地址：思科的Linksys无线路由和调制解调器一般为你家里的电脑和笔记本分配一个在上述范围内的私有地址，之后把你所有的网络流量隐藏到你的网络供应商提供给你的那个“真实IP地址”下面去（表面上所有数据都和“真实IP地址“进行交互， 实际上数据在和私有范围内的IP进行交互，这些IP无法访问）。

### Routing
------
比如说我们现在有一个实现了网络协议并且向8.8.4.4这个IP地址发送数据包的操作系统，这个操作系统要如何使用和它所在计算机相连的物理网络进行信息的传输呢？**这种根据目标IP地址而去决定向哪里发信息的问题称之为，路由**。大多数Python代码实际上都会在位于网络边缘的主机上运行：Python代码基本不会在网关主机上运行（python不用于实现路由）——**网关连接子网中多个不同主机，同时还提供一个连接广域网络的接口**。有了网关，路由就很简单了：

- 对于像127.*.*. * 这样的IP地址，**操作系统知道这个IP地址指向了本地的另一个应用**。

- 如果IP地址位于**该机器所处的子网之内**，那么可以通过**直接查询本地以太网段（local Ethernet segment）、无线频道或者任何可以构成本地网络的东西，之后再将包发送给那个本地相连接目标主机，来进行通信**。

- 否则，机器会将包**发送给一个能把本地子网和广域网连接的网关**。接下来由网关决定把这个包往哪里发送。

  ​

  当然了，也就只有在边缘网络内的时候，路由才会如此简单。因为，在这里只需要决定究竟是把包留在本地子网内，还是把包向广域网络发送。可以想到，在构成网络主干的设备上，路由决策更加复杂。因此路由器上的路由表必须频繁更新。只有频繁更新，发给google、雅虎以及你的计算机的信息才能分别地正确送达。但是，Python应用几乎不会在路由器上运行。所以你能接触到的路由，基本上就是上述那样的。

先前对于计算机如何决定一个IP地址是否位于子网内或者是否位于网关之外的讨论其实笼统了一些。为了描述子网——所有带有相同前缀IP地址的主机——的概念，我之前用了星号来代表前缀之外的其他地址。**当然了，作为位于操作系统上的一个仅具备二元逻辑的网络栈，是没有办法把一个ASCII中的 * 插入到路由表中去的**。实际上，子网通过**子网掩码来界定**：子网掩码能表示出：一个IP地址如果是该子网之内的主机，**它必须有多少位能匹配**。如果你能看出来IP地址所对应的二元形式，那你就能轻松地读懂子网掩码（还是那句话，网络栈只能进行二元计算，所以要通过二进制序列的匹配进行识别）：

- 127.0.0.0/8: 这个形式描述了我们先前提到的一个IP地址范围。这个IP范围是给本地主机预留的。所以本地主机的IP地址的前8位（一个比特）必须能够匹配127，剩下的24位是任意的。

- 192.168.0.0/16: 这个形式能匹配192.168这个私有范围内的任何IP地址，因为前十六位数字能完全匹配。

- 192.168.5.0/24: 这个形式就能定位到一个特定的独立的子网了。这基本上是网络上最为常见的子网掩码的形式。前三个比特已经指定好了。只有最后八位可以随着机器变动，这样就能产生256个完全不同的地址。其中，0地址用来命名整个子网；255地址则用来实现“广播包”——用来联系子网内的其他主机。这样就剩下了254个可用地址，这些地址才能分配给计算机。1地址常用来分配给连接子网和广域网的网关，不过也有用其他地址来指定网关的情况。

日常工作中，Python代码基本上要把数据包路由选择的工作完全交给操作系统，就像主机名映射为IP地址的工作那样。

### Packet Fragmentation
------
最后一个还没提的概念是分包。虽然现在分包工作已经被操作系统网络栈十分成功地隐藏起来了，但在历史上分包曾经引起过很多问题。分包是必要的，因为虽然网络协议能够传输很大的包——长度高达64kb——但是实际网络设备都被设计成了仅能支持小包的设备。**比如说，以太网仅能支持1500比特的包**。包因此会含一个DF标记。DF标记能让发送者决定当包太小而不能被传输的时候该怎么办：

- 如果**没有设置DF标记**，那么就**允许分包**，如果包太大而不能进行传输，网关就把它分成可以传输的包。同时，也在各个包上做标记，来保证它们被传输到另一端之后能被重新拼出来。

- 如果包设置了**DF标记**，那就**不允许分包**。如果这个时候包大小不适合传输呢？包就会被直接丢弃，同时会发送回来一个异常，通常是一个ICMP包。

**Python程序不能控制DF标记，这个工作由操作系统掌握。操作系统在这里的处理办法是：如果用户进行的是UDP通信，系统就不会为通信用的包设置DF标记。这样传输的数据包就可以被任意分包；但如果用户进行的是TCP通信——需要连续长时间地传送几百几千个包，那么操作系统就会为之设置DF标记**。

这样，操作系统就能指定合适的包的大小来保证通信顺畅地进行，从而避免了通信由于过分分包而出现效率过低的情况。一个子网能够接受的最大的包成为一个最大传输单元（MTU），过去关于MTU的处理曾经困扰过很多网络用户。

上个世界九十年代，网络服务提供商（主要是一些提供DSL链接的电话运营商）开始使用PPPoE——一种只允许输1492比特而不是1500比特的网络协议。很多网络站点都没有为这种网络协议做实现的准备，他们照样默认使用1500比特包之后却屏蔽掉了所有ICMP包。因此他们的服务器就永远都接收不到服务器提供的错误信息——未设置DF标记的大型数据包不能被传输。

这种情况引起的问题是：那些小型文件和网页都能正常处理，Telnet和SSH这样的交互协议也能正确工作，因为这些协议首发的都是小包。但是一旦用户试图下载比较大的文件，或者一旦Telnet命令产生了很多输出的话，网络连接就无法使用了。今天这个问题基本不会出现，但是这个问题说明了一个底层IP特性甚至能产生一种用户可见的问题——因此理解IP的所有特征其实是有好处的，尤其是在编辑和修改网络程序的时候。